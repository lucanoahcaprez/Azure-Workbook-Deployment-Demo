# Pipeline Fix: Artifact Access Issue

## Problem
The deploy workflow was failing with the error:
```
Unable to download artifact(s): Resource not accessible by integration
```

This occurred because `workflow_run` triggers create a different security context, and artifacts from the combine workflow weren't accessible to the deploy workflow due to GitHub's security restrictions.

## Solution
Instead of using artifacts to pass the ARM template between workflows, we now use the Git repository itself as the source of truth:

### 1. **Combine Workflow Approach**
- Generates ARM template using PowerShell script
- Commits the updated ARM template to the repository
- ❌ **Removed**: Artifact upload (no longer needed)

### 2. **Deploy Workflow Approach**
- ❌ **Removed**: Artifact download step
- ✅ **Updated**: Checkout step to get the latest commit from the combine workflow
- Uses `github.event.workflow_run.head_sha` to checkout the exact commit that triggered the workflow

### 3. **Key Changes Made**

#### Deploy Workflow (`deploy-arm-template.yml`)
```yaml
- name: Checkout code
  uses: actions/checkout@v4
  with:
    # When triggered by workflow_run, checkout the head commit from that workflow
    ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}
```

#### Combine Workflow (`combine-workbook-into-arm.yml`)
- Removed the artifact upload step
- Continues to commit ARM template changes to the repository

## Benefits of This Approach

### ✅ **Security Compliant**
- No cross-workflow artifact access issues
- Uses standard Git operations that work across workflow triggers

### ✅ **Reliable**
- ARM template is always available in the repository
- Deploy workflow gets the exact version generated by combine workflow

### ✅ **Auditable**
- All ARM template changes are tracked in Git history
- Clear commit messages show when templates were auto-generated

### ✅ **Simple**
- Fewer moving parts than artifact-based approach
- Standard Git checkout operation that GitHub Actions handles well

## How It Works Now

1. **Combine Workflow Runs**:
   - Generates ARM template
   - Commits to repository with commit SHA `ABC123`
   - Triggers deploy workflow

2. **Deploy Workflow Runs**:
   - Receives `workflow_run` event with `head_sha: ABC123`
   - Checks out commit `ABC123` (the exact commit with the new ARM template)
   - Proceeds with deployment using the correct ARM template

This approach is more reliable and aligns with GitHub Actions best practices for workflow chaining!